spring.application.name=userservice
server.port=${PORT}

##  Kafka broker connection
spring.kafka.bootstrap-servers=${KAFKA_BOOTSTRAP}
spring.kafka.topic-name=${KAFKA_TOPIC}

## Consumer group configuration
# Tracks offsets so you don't reprocess old messages after restart
spring.kafka.consumer.group-id=${KAFKA_GROUP:user-service-group-v3}
# On first run for this group, read from the beginning of the topic
spring.kafka.consumer.auto-offset-reset=earliest

##  Key deserialization
# Matches producer's StringSerializer for keys
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
logging.level.org.apache.kafka=INFO
logging.level.org.springframework.kafka=DEBUG

## Value deserialization
# Matches producer's JsonSerializer for values
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.ErrorHandlingDeserializer
spring.kafka.consumer.properties.spring.deserializer.value.delegate.class=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.value.default.type=com.example.userservice.model.UserSignUpEventDto
spring.kafka.consumer.properties.spring.json.use.type.headers=false

## Map producer DTO class (from authservice) to local DTO class to avoid class mismatch
spring.kafka.consumer.properties.spring.json.type.mapping=com.example.authservice.model.UserSignUpEventDto:com.example.userservice.model.UserSignUpEventDto

## Target type & trust boundaries
# Only trust your DTO package to reduce security risk
spring.kafka.consumer.properties.spring.json.trusted.packages=*

# MySQL database connection settings
spring.datasource.url=${DB_URL}
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWORD}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver


# Hibernate/JPA settings
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQLDialect